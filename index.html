<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D粒子隔空操控 (修复版)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* 调试信息显示区 */
        #debug-log {
            position: absolute; top: 10px; left: 10px; width: 90%;
            color: red; font-family: sans-serif; font-size: 12px;
            z-index: 20; pointer-events: none; background: rgba(0,0,0,0.5);
        }

        /* 摄像头预览 */
        .input_video { 
            position: absolute; bottom: 10px; right: 10px; 
            width: 120px; height: 90px; z-index: 2; opacity: 0.5; 
            border-radius: 8px; transform: scaleX(-1); border: 1px solid #333; 
            object-fit: cover;
        }
        
        /* 启动界面 */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 15;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
        }
        
        #start-btn {
            padding: 15px 40px; background: #0ff; color: #000; border: none;
            font-size: 18px; border-radius: 30px; cursor: pointer;
            font-weight: bold; box-shadow: 0 0 20px #0ff;
            margin-top: 20px;
        }

        #loading-text {
            color: #fff; margin-bottom: 20px; font-family: monospace;
        }
    </style>
</head>
<body>

    <div id="debug-log"></div>

    <div id="overlay">
        <div id="loading-text">准备就绪...</div>
        <button id="start-btn">点击开始 (开启摄像头)</button>
    </div>

    <video class="input_video" playsinline webkit-playsinline muted autoplay></video>
    
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- 日志工具 ---
        function log(msg) {
            const logDiv = document.getElementById('debug-log');
            logDiv.innerHTML += msg + "<br>";
            console.log(msg);
        }

        // --- 1. Three.js 渲染部分 (保持不变) ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.001);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 400;
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // 粒子初始化
        const particleCount = 8000; // 稍微减少粒子数以提高手机性能
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const originalPositions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const color1 = new THREE.Color(0xffaa00);
        const color2 = new THREE.Color(0xff5500);

        for (let i = 0; i < particleCount; i++) {
            const radius = 100 + Math.random() * 50;
            const theta = Math.random() * Math.PI * 2;
            const y = (Math.random() - 0.5) * 600;
            const x = radius * Math.cos(theta);
            const z = radius * Math.sin(theta);
            positions[i * 3] = x; positions[i * 3 + 1] = y; positions[i * 3 + 2] = z;
            originalPositions[i * 3] = x; originalPositions[i * 3 + 1] = y; originalPositions[i * 3 + 2] = z;
            const mixedColor = color1.clone().lerp(color2, Math.random());
            colors[i * 3] = mixedColor.r; colors[i * 3 + 1] = mixedColor.g; colors[i * 3 + 2] = mixedColor.b;
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        const material = new THREE.PointsMaterial({ size: 4, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.8 });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        let targetX = 0; let targetY = 0; let isHandDetected = false;
        const interactionRadius = 150;

        function animate() {
            requestAnimationFrame(animate);
            particles.rotation.y += 0.002;
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                const px = positions[i * 3]; const py = positions[i * 3 + 1]; const pz = positions[i * 3 + 2];
                const ox = originalPositions[i * 3]; const oy = originalPositions[i * 3 + 1]; const oz = originalPositions[i * 3 + 2];
                let vx = (ox - px) * 0.05; let vy = (oy - py) * 0.05; let vz = (oz - pz) * 0.05;
                if (isHandDetected) {
                    const dx = px - targetX; const dy = py - targetY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < interactionRadius) {
                        const force = (interactionRadius - dist) / interactionRadius;
                        const angle = Math.atan2(dy, dx);
                        const pushStrength = 25;
                        vx += Math.cos(angle) * force * pushStrength;
                        vy += Math.sin(angle) * force * pushStrength;
                        vz += Math.sin(dist * 0.1) * force * 15;
                    }
                }
                positions[i * 3] += vx; positions[i * 3 + 1] += vy; positions[i * 3 + 2] += vz;
            }
            particles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        // --- 2. AI 和 摄像头逻辑 ---
        const videoElement = document.getElementsByClassName('input_video')[0];
        const startBtn = document.getElementById('start-btn');
        const loadingText = document.getElementById('loading-text');
        const overlay = document.getElementById('overlay');

        let hands;
        let cameraUtils;

        // 初始化 Hands 模型
        async function initHands() {
            try {
                loadingText.innerText = "正在下载 AI 模型 (约10MB)...";
                hands = new Hands({locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }});
                
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1,
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                
                hands.onResults(onResults);
                loadingText.innerText = "模型加载完成，等待摄像头...";
                startBtn.style.display = "block"; // 模型准备好了再显示按钮
            } catch (e) {
                log("模型初始化失败: " + e.message);
            }
        }

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const indexFinger = landmarks[8];
                // 映射坐标
                targetX = (1 - indexFinger.x) * 600 - 300;
                targetY = (1 - indexFinger.y) * 400 - 200;
                isHandDetected = true;
            } else {
                isHandDetected = false;
            }
        }

        // 点击按钮启动
        startBtn.addEventListener('click', () => {
            loadingText.innerText = "正在请求摄像头权限...";
            startCamera();
        });

        function startCamera() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                log("错误: 浏览器不支持摄像头，或环境不安全(需要HTTPS)");
                return;
            }

            cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });

            cameraUtils.start()
                .then(() => {
                    overlay.style.display = 'none'; // 隐藏遮罩
                    log("摄像头已启动");
                })
                .catch(err => {
                    log("摄像头启动失败: " + err);
                    log("提示: 手机访问必须使用 HTTPS 协议，不能用 http://IP");
                });
        }

        // 页面加载即初始化模型
        initHands();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
